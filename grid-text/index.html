<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Text</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
  <script>
    function setViewportScale() {
      const viewport = document.getElementById('viewport')
      if (/Mobi/.test(navigator.userAgent)) {
        viewport.setAttribute('content', 'width=device-width, initial-scale=2.0')
      }
    }
    setViewportScale()
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
<script>
const config = {
  bg: '#000',
  textColor: 255,
  textOpacity: 50,
  cellSize: 16,
  fontSize: 12,
  line1: 'Grid',
  line2: 'Text',
  frameRate: 6,
  moveInterval: 6000
}

const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

let cols, rows, verticalRow, startCol, grid = [], xPos = [], yPos = []
let normalStyle, fadeStyle
let lastUpdate = 0
let lastMove = 0
const updateInterval = 50

// Performance: pre-rendered character sprites and off-screen buffer
let charSprites = {}
let fadeSprites = {}
let bgBuffer = null
let needsRedraw = true

function setup() {
  pixelDensity(window.devicePixelRatio > 1 ? 2 : 1)
  createCanvas(windowWidth, windowHeight)
  frameRate(config.frameRate)
  textFont('Courier New')
  textSize(config.fontSize)
  textAlign(CENTER, CENTER)

  normalStyle = color(config.textColor)
  fadeStyle = color(config.textColor, config.textOpacity)

  // Pre-render all characters as sprites for fast blitting
  preRenderCharSprites()

  updateGrid()
}

function preRenderCharSprites() {
  const size = config.cellSize

  for (let i = 0; i < chars.length; i++) {
    const c = chars[i]

    // Normal brightness sprite
    const normal = createGraphics(size, size)
    normal.textFont('Courier New')
    normal.textSize(config.fontSize)
    normal.textAlign(CENTER, CENTER)
    normal.fill(config.textColor)
    normal.text(c, size / 2, size / 2)
    charSprites[c] = normal

    // Faded sprite
    const faded = createGraphics(size, size)
    faded.textFont('Courier New')
    faded.textSize(config.fontSize)
    faded.textAlign(CENTER, CENTER)
    faded.fill(config.textColor, config.textOpacity)
    faded.text(c, size / 2, size / 2)
    fadeSprites[c] = faded
  }
}

function updateGrid() {
  cols = floor(width / config.cellSize)
  rows = floor(height / config.cellSize)
  verticalRow = floor(random(5, rows - 5))
  startCol = floor(random(0, cols - 8))

  const halfCell = config.cellSize / 2
  xPos = Array(cols).fill().map((_, i) => i * config.cellSize + halfCell)
  yPos = Array(rows).fill().map((_, i) => i * config.cellSize + halfCell)

  grid = Array(cols).fill().map(() =>
    Array(rows).fill().map(() => chars[floor(random(chars.length))])
  )

  // Create or resize off-screen buffer
  if (!bgBuffer || bgBuffer.width !== width || bgBuffer.height !== height) {
    if (bgBuffer) bgBuffer.remove()
    bgBuffer = createGraphics(width, height)
  }

  needsRedraw = true
}

function updateChars() {
  const l1len = config.line1.length
  const l2len = config.line2.length
  const charsLen = chars.length

  // Update all cells except where text overlay is
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      if (!(i >= startCol && i < startCol + (j === verticalRow ? l1len : l2len) &&
          (j === verticalRow || j === verticalRow + 1))) {
        grid[i][j] = chars[floor(random(charsLen))]
      }
    }
  }

  needsRedraw = true
}

function renderBackgroundToBuffer() {
  bgBuffer.background(config.bg)

  const size = config.cellSize
  const maxLen = Math.max(config.line1.length, config.line2.length)

  // Use image() with pre-rendered sprites instead of text() calls
  for (let i = 0; i < cols; i++) {
    const x = i * size
    const inRange = i >= startCol && i < startCol + maxLen

    for (let j = 0; j < rows; j++) {
      if (inRange && (j === verticalRow || j === verticalRow + 1)) continue
      bgBuffer.image(fadeSprites[grid[i][j]], x, j * size)
    }
  }
}

function draw() {
  const now = millis()

  if (now - lastUpdate > updateInterval) {
    lastUpdate = now
    updateChars()
  }

  if (now - lastMove > config.moveInterval) {
    lastMove = now
    verticalRow = floor(random(5, rows - 5))
    startCol = floor(random(0, cols - 8))
    needsRedraw = true
  }

  // Only re-render background buffer when needed
  if (needsRedraw) {
    renderBackgroundToBuffer()
    needsRedraw = false
  }

  // Blit the pre-rendered background (single image call)
  image(bgBuffer, 0, 0)

  // Draw foreground text using sprites
  const size = config.cellSize
  const y1 = verticalRow * size
  const y2 = (verticalRow + 1) * size

  for (let i = 0; i < config.line1.length && startCol + i < cols; i++) {
    image(charSprites[config.line1[i]], (startCol + i) * size, y1)
  }
  for (let i = 0; i < config.line2.length && startCol + i < cols; i++) {
    image(charSprites[config.line2[i]], (startCol + i) * size, y2)
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight)
  updateGrid()
}

</script>
</body>
</html>