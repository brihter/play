<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Bostjan Rihter">
  <meta itemprop="name" content="Izvir">
  <meta itemprop="description" content="Izvir">
  <meta itemprop="image" content="https://brihter.github.io/play/izvir/preview.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Izvir">
  <meta name="twitter:description" content="Izvir">
  <meta name="twitter:image:src" content="https://brihter.github.io/play/izvir/preview.png">
  <meta property="og:title" content="Izvir" />
  <meta property="og:description" content="Izvir" />
  <meta property="og:image" content="https://brihter.github.io/play/izvir/preview.png" />
  <title>Izvir</title>
  <script src="math.js"></script>
  <script src="layer.js"></script>
  <script src="shape.js"></script>
  <script src="fx.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    canvas {
      image-rendering: pixelated;
    }
  </style>
</head>

<body>
  <script>
    (() => {
      const { toMatrix } = layer()

      const FACTOR = 3
      const FPS = 60
      const FPS_DELTA = parseInt(1000 / FPS)
      const PIXEL_SIZE = 6

      const COLOR_DARK = 'rgb(26, 26, 26)'
      const COLOR_LIGHT = 'rgb(218, 218, 218)'

      // Pre-parse color palettes to RGB arrays for direct ImageData manipulation
      const parseColor = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16)
        const g = parseInt(hex.slice(3, 5), 16)
        const b = parseInt(hex.slice(5, 7), 16)
        return [r, g, b]
      }

      const COLOR_PALETTE_1 = ['#c1c1c1', '#a7a7a7', '#8e8e8e', '#747474', '#5b5b5b'].map(parseColor)
      const COLOR_PALETTE_2 = ['#5EE6CD', '#129A81', '#008067', '#00674E', '#004D34'].map(parseColor)

      let centerX
      let centerY
      let windowWidth
      let windowHeight

      const makeOuterCircle = () => {
        const circle = layer().create('logoOuterCircle')
        shape.circle(circle, {
          mode: 'stroke',
          x: centerX,
          y: centerY,
          radius: 42 * FACTOR,
          strokeStyle: COLOR_LIGHT,
          lineWidth: 14 * FACTOR,
          startAngle: (3 * Math.PI / 4) + Math.PI,
          endAngle: (Math.PI / 4) + Math.PI
        })

        const pixels = toMatrix({
          layer: circle,
          size: PIXEL_SIZE
        })

        circle.element.remove()

        return pixels
      }

      const makeInnerCircle = () => {
        const circle = layer().create('logoInnerCircle')
        shape.circle(circle, {
          mode: 'stroke',
          x: centerX,
          y: centerY,
          radius: 24 * FACTOR,
          strokeStyle: COLOR_LIGHT,
          lineWidth: 4 * FACTOR
        })

        const pixels = toMatrix({
          layer: circle,
          size: PIXEL_SIZE
        })

        circle.element.remove()

        return pixels
      }

      const makePie = () => {
        const pie = layer().create('logoPie')
        shape.pie(pie, {
          x: centerX,
          y: centerY,
          radius: 60 * FACTOR,
          mode: 'fill',
          fillStyle: COLOR_LIGHT,
          startAngle: (Math.PI / 3) + Math.PI,
          endAngle: (2 * Math.PI / 3) + Math.PI
        })

        const pixels = toMatrix({
          layer: pie,
          size: PIXEL_SIZE
        })

        pie.element.remove()

        return pixels
      }

      // Performance: Direct ImageData manipulation instead of thousands of fillRect calls
      const pixelateToImageData = (imageData, pixels, colorPalette, pixelSize, canvasWidth) => {
        const data = imageData.data
        const paletteLen = colorPalette.length
        const actualSize = pixelSize - 1

        for (let p = 0; p < pixels.length; p++) {
          const px = pixels[p][0] + 1
          const py = pixels[p][1] + 1
          const color = colorPalette[(Math.random() * paletteLen) | 0]
          const r = color[0], g = color[1], b = color[2]

          // Fill the pixel block directly in ImageData
          for (let dy = 0; dy < actualSize; dy++) {
            const rowOffset = ((py + dy) * canvasWidth + px) * 4
            for (let dx = 0; dx < actualSize; dx++) {
              const idx = rowOffset + dx * 4
              data[idx] = r
              data[idx + 1] = g
              data[idx + 2] = b
              data[idx + 3] = 255
            }
          }
        }
      }

      let background
      let pixelLayer
      let outerCircle
      let innerCircle
      let pie
      let imageData

      let stop = false
      const init = () => {
        stop = true

        windowWidth = window.innerWidth
        windowHeight = window.innerHeight
        centerX = window.innerWidth / 2
        centerY = window.innerHeight / 2

        if (background) {
          background.element.remove()
        }

        background = layer().create('background')
        fx.fill(background, { color: COLOR_DARK })

        if (pixelLayer) {
          pixelLayer.element.remove()
        }

        pixelLayer = layer().create('pixels')

        // Pre-allocate ImageData buffer for direct pixel manipulation
        imageData = pixelLayer.ctx.createImageData(windowWidth, windowHeight)

        outerCircle = makeOuterCircle()
        innerCircle = makeInnerCircle()
        pie = makePie()
        stop = false

        window.requestAnimationFrame(loop)
      }

      const paint = () => {
        // Clear ImageData buffer (set all alpha to 0)
        const data = imageData.data
        for (let i = 3; i < data.length; i += 4) {
          data[i] = 0
        }

        // Render all pixels directly to ImageData buffer
        pixelateToImageData(imageData, outerCircle, COLOR_PALETTE_2, PIXEL_SIZE, windowWidth)
        pixelateToImageData(imageData, innerCircle, COLOR_PALETTE_1, PIXEL_SIZE, windowWidth)
        pixelateToImageData(imageData, pie, COLOR_PALETTE_2, PIXEL_SIZE, windowWidth)

        // Single putImageData call instead of thousands of fillRect
        pixelLayer.ctx.putImageData(imageData, 0, 0)
      }

      let lastFrameTime = 0
      const loop = (elapsedTime = 0) => {
        if (stop) {
          return
        }

        const delta = elapsedTime - lastFrameTime
        window.requestAnimationFrame(loop)
        if (lastFrameTime && delta < FPS_DELTA) {
          return
        }

        paint()
        lastFrameTime = elapsedTime
      }

      // Debounce resize handler to prevent excessive reinitialization
      let resizeTimeout
      const debouncedInit = () => {
        clearTimeout(resizeTimeout)
        resizeTimeout = setTimeout(init, 100)
      }

      window.addEventListener('resize', debouncedInit)
      init()
    })()
  </script>
</body>

</html>